# tree
西南交通大学算法分析第五次作业动态规划
定义树中某结点的平衡为删除该结点后所形成的森林中各树结点数的最大值。如下图左边的树，如果删除其中的一个结点3，则该树变成右边的森林，也就是多棵树，这些树的结点数分别为6，1，1，1，其最大值为6，因此结点3的平衡为6。
 
    在给定一棵树的情况下，求该树中所有结点的最小平衡数。
输入要求：
输入的第一行是一个整数n（(1 <= n<= 20)，表示测试数据的组数。每一组测试数据的第一行是一个整数m (1 <= m <= 20,000)，表示树中的一对结点，其后的N-1行，每一行包含两个整数，表示树中相连的两个结点。树中结点的编号从1开始编号。
输出要求：
对于每一组测试数据输出一行，表示该树中所有结点的平衡数的最小值。
输入样例：
1
9
1 2
1 3
1 4
2 5
3 6
3 7
3 8
4 9
4 10
输出样例：
4
算法设计思路：
设置power数组来记录该结点具有的权重，fpower数组记录该结点以外的权重，maxpower数组记录该结点底层权重和fpower的最大值，minpower记录maxpower中的最小值。首先做一次深度遍历，power[i]+=find(j)，j为子结点，同时maxpower[i]=max(maxpower[i],find[j])找出子结点权重最大值，之后做maxpower[i]=max(maxpower[i],fpower[i])，找出该结点权重最大值，最后minpower=min(maxpower[i],minpower)，找出平衡
算法复杂度：T(n)=O(n)
状态转移函数：minpower=min(maxpower[i],minpower)

这道题难度忒小了，不愧只值10分

如果你第一次用GitHub的话，直接找上面的.cpp文件就好，代码在里面
